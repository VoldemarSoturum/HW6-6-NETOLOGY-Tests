#Задача №1 unit-tests

# Напишите тесты на любые 3 задания из модуля «Основы языка программирования Python». 
# Используйте своё решение домашнего задания.
# При написании тестов не забывайте использовать параметризацию.
# Рекомендации по тестам: если у вас в функциях информация выводилась (print), 
# то теперь её лучше возвращать (return), чтобы можно было протестировать.

#============================================================================
import unittest

# в PYTEST есть встроенная параметризация которая имеет конструкцию:
#     @pytest.mark.parametrize("hare_dist,turtle_dist,expected", [...])

# Библиотека parameterized - используется для параметризации тестов 
# в Python, то есть запуска одного теста с разными наборами 
# входных данных. Это мощный инструмент для уменьшения 
# дублирования кода в тестах.
from parameterized import parameterized # pip install parameterized

#Задание «Кто дальше?»

def solve(hare_distances: list, turtle_distances: list):
    hare_all = 0 # подсчитайте общую дистанцию зайца
    for hare_distance in hare_distances:
        hare_all += hare_distance
    turtle_all = 0 # подсчитайте общую дистанцию черепахи
    for turtle_distance in turtle_distances:
        turtle_all += turtle_distance
    # определите, кто из двоих прошел бОльшую дистанцию
    if hare_all>turtle_all:
        result = "заяц"
    elif hare_all<turtle_all:
        result = "черепаха"
    else:
        result = "одинаково"
    return result

if __name__ == '__main__':
    # Этот код менять не надо
    result = solve([8, 5, 3, 2, 0, 1, 1], [3, 3, 3, 3, 3, 3, 3])
    assert result == "черепаха", f"Победитель определен неверно: {result}"
    print(f"Победитель: {result}")
    result = solve([8, 5, 3, 2, 2, 1, 1], [3, 3, 3, 3, 3, 3, 3])
    assert result == "заяц", f"Победитель определен неверно: {result}"
    print(f"Победитель: {result}")
    result = solve([8, 5, 3, 2, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3])
    assert result == "одинаково", f"Победитель определен неверно: {result}"
    print(f"Победитель: {result}")

# #===============================TESTS=================================
#+++++++++++++Тесты которые будут пройдены:

# Декоратор @parameterized.expand позволяет создать 
# несколько тестовых случаев из одного метода тестирования.
# Каждый кортеж в списке - отдельный тестовый случай.
class TestSolveFunction(unittest.TestCase):
    @parameterized.expand([
    
    # Первый тестовый случай - черепаха побеждает
    # Параметры:
    # 1. "turtle_wins" - название теста (для отчета)
    # 2. [8,5,3,2,0,1,1] - дистанции зайца на каждом этапе
    # 3. [3,3,3,3,3,3,3] - дистанции черепахи на каждом этапе
    # 4. "черепаха" - ожидаемый результат   

    # Если побеждает черепаха
    ("turtle_wins", [8, 5, 3, 2, 0, 1, 1], [3, 3, 3, 3, 3, 3, 3], "черепаха"),

    # Если побеждает заяц.
    ("hare_wins", [8, 5, 3, 2, 2, 1, 1], [3, 3, 3, 3, 3, 3, 3], "заяц"),

    # Если бьудет ничья
    ("draw", [8, 5, 3, 2, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3], "одинаково"),

    # Дополнительные тестовые случаи:
    # Пустой список дистанций зайца
    ("empty_hare", [], [1, 2, 3], "черепаха"),

    # Пустой список дистанций черепахи
    ("empty_turtle", [1, 2, 3], [], "заяц"),

    # Оба списка пустые
    ("both_empty", [], [], "одинаково"),

    # Гонка из одного этапа (заяц побеждает)
    ("single_race_hare", [10], [5], "заяц"),

    # Гонка из одного этапа (черепаха побеждает)
    ("single_race_turtle", [3], [5], "черепаха"),

    # Гонка из одного этапа (ничья)
    ("single_race_draw", [5], [5], "одинаково"),

    # Длинная гонка (100 этапов, заяц побеждает)
    # [1]*100 создает список из 100 единиц
    ("longer_race_hare", [1]*100, [0.5]*100, "заяц"),

    # Длинная гонка (50 этапов, черепаха побеждает)
    ("longer_race_turtle", [1]*50, [2]*50, "черепаха"),

    # Отрицательные значения дистанций
    ("negative_values", [-1, -2, -3], [1, 2, 3], "черепаха"),
    ])

    def test_race_scenarios(self, name, hare_dist, turtle_dist, expected):
        """Тестирование различных сценариев гонки"""
        # Призываем функцию отвечающую за тестирование
        result = solve(hare_dist, turtle_dist)
        # Проверяем что результат соответствует ожидаемому сравнивая 
        # значения result и expected, проверяет их равенство (эквивалент)
        # Если значения не равны, то этот метод генерирует исключение AssertionError
        self.assertEqual(result, expected)
        # self.assertEqual выполняет:
        #   if result != expected:
        #       raise AssertionError(f"{result} != {expected}")
    def test_invalid_input(self):
        """Тестирование невалидных входных данных"""
        # assertRaises -- проверяет, что код 
        # внутри блока вызывает ожидаемое исключение 
        # (в нашем случае TypeError).
            # Создаёт контекстный менеджер для перехвата исключений

            # Если код НЕ вызывает исключение - тест падает

            # Если код вызывает ПРАВИЛЬНОЕ исключение - тест проходит

            # Если код вызывает НЕПРАВИЛЬНОЕ исключение - тест падает
        #!!ВАЖННО!!Особенности теста:
                # Точное совпадение типа: проверяет именно тот класс исключения, который указан
                # Контекстный менеджер: обязательно используйте конструкцию with
        
         # Проверка для первого параметра-строки
        with self.assertRaises(TypeError):
            solve("not a list", [1, 2, 3])
        # Проверка для второго параметра-строки  
        with self.assertRaises(TypeError):
            solve([1, 2, 3], "not a list")
        # Проверка для None вместо первого параметра
        with self.assertRaises(TypeError):
            solve(None, [1, 2, 3])
        # Проверка для None вместо второго параметра
        with self.assertRaises(TypeError):
            solve([1, 2, 3], None)

# Точка входа для выполения тестов.

# !!!ВАЖНО!!!
    # Тесты запустятся только при прямом запуске файла
    # При импорте файла как модуля тесты не запустятся

if __name__ == '__main__':  # Если файл запущен напрямую, то...

    # unittest.main():
        # Ищет все тестовые классы (наследники unittest.TestCase)
        # Собирает все методы, начинающиеся с test_
        # Запускает тесты и выводит результаты
    unittest.main()

